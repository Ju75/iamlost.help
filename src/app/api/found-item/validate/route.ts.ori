// src/app/api/found-item/validate/route.ts - FIXED VERSION
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getUserFromEncryptedToken } from '@/lib/unique-id';
import { createHash } from 'crypto';

const prisma = new PrismaClient();

// Generate a display ID from token for fake IDs
function generateDisplayIdFromToken(token: string): string {
  const hash = createHash('sha256').update(`display_${token}_${process.env.NEXTAUTH_SECRET || 'fallback'}`).digest('hex');
  return hash.substring(0, 6).toUpperCase();
}

export async function POST(request: NextRequest) {
  try {
    console.log('üîç Validate API called');
    
    const body = await request.json();
    console.log('üì¶ Request body:', body);
    
    const { encryptedToken } = body;

    if (!encryptedToken) {
      console.log('‚ùå No encrypted token provided');
      return NextResponse.json({
        success: true,
        displayId: 'DEMO01',
        isRealUser: false
      });
    }

    console.log('üîê Validating token:', encryptedToken.substring(0, 20) + '...');

    // Try to find the real display ID from the encrypted token
    try {
      const uniqueIdRecord = await prisma.uniqueId.findUnique({
        where: { encryptedToken },
        select: { 
          displayId: true,
          userId: true,
          status: true,
          user: {
            select: {
              status: true
            }
          }
        }
      });

      console.log('üë§ Database lookup result:', uniqueIdRecord ? 'FOUND' : 'NOT FOUND');

      if (uniqueIdRecord && uniqueIdRecord.status === 'ACTIVE' && uniqueIdRecord.user.status === 'ACTIVE') {
        // Check if user has active subscription
        const subscription = await prisma.subscription.findFirst({
          where: {
            userId: uniqueIdRecord.userId,
            status: 'ACTIVE',
            currentPeriodEnd: {
              gt: new Date()
            }
          }
        });

        console.log('üí≥ Subscription found:', subscription ? 'YES' : 'NO');

        if (subscription) {
          console.log('‚úÖ Real user validation successful');

          const responseData = {
            success: true,
            displayId: uniqueIdRecord.displayId, // Return the REAL display ID
            isRealUser: true
          };

          console.log('üì§ Returning real user data:', responseData);
          return NextResponse.json(responseData);
        }
      }
    } catch (error) {
      console.log('Error validating real user, falling back to fake user behavior');
    }

    // If we get here, it's either a fake ID or invalid real ID
    // ALWAYS return success for demo purposes
    const fakeDisplayId = generateDisplayIdFromToken(encryptedToken);
    
    console.log('‚úÖ Fake ID validation - returning success anyway');

    const responseData = {
      success: true,
      displayId: fakeDisplayId,
      isRealUser: false
    };

    console.log('üì§ Returning fake user data:', responseData);
    return NextResponse.json(responseData);

  } catch (error) {
    console.error('‚ùå Error in validate API:', error);
    
    // Even on error, ALWAYS return success for demo purposes
    const fakeDisplayId = generateDisplayIdFromToken(encryptedToken || 'error');
    
    console.log('‚úÖ Error case - still returning success for demo');
    
    return NextResponse.json({
      success: true,
      displayId: fakeDisplayId,
      isRealUser: false
    });
  }
}
