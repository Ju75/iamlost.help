// src/app/api/found-item/report/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getUserFromDisplayId, normalizeDisplayId } from '@/lib/unique-id';
import { sendFoundItemNotification } from '@/lib/email';
import { createHash } from 'crypto';

const prisma = new PrismaClient();

// Function to check if a token was generated by our lookup API (not a real encrypted token)
function isGeneratedToken(token: string, originalId: string): boolean {
  const expectedToken = createHash('sha256').update(`token_salt_${originalId}_${process.env.NEXTAUTH_SECRET || 'fallback'}`).digest('hex').substring(0, 64);
  return token === expectedToken;
}

// Extract the original display ID from the token
function extractDisplayIdFromToken(token: string): string | null {
  // We need to reverse-engineer this, but since we generate deterministic tokens,
  // we can store the mapping or try common patterns
  // For now, let's try to decode from the form data or use a different approach
  return null; // We'll pass the displayId separately or use a different method
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    console.log('Received found item report:', body);

    const {
      encryptedToken,
      finderName,
      finderEmail,
      finderPhone,
      message,
      location,
      itemType,
      displayId // We should pass this from the frontend
    } = body;

    // Validate required fields
    if (!encryptedToken || !finderName || !finderEmail || !message || !location || !itemType) {
      return NextResponse.json(
        { error: 'Missing required fields' },
        { status: 400 }
      );
    }

    // Get request details for tracking
    const forwardedFor = request.headers.get('x-forwarded-for');
    const realIp = request.headers.get('x-real-ip');
    const clientIp = forwardedFor?.split(',')[0] || realIp || 'unknown';
    const userAgent = request.headers.get('user-agent') || 'unknown';

    // First, try to find if this is a real encrypted token from the database
    let userId: number | null = null;
    let isRealToken = false;

    try {
      // Try to find a real encrypted token in the database
      const uniqueIdRecord = await prisma.uniqueId.findUnique({
        where: { encryptedToken },
        select: { userId: true, displayId: true, id: true }
      });

      if (uniqueIdRecord) {
        userId = uniqueIdRecord.userId;
        isRealToken = true;
        console.log('Real token found for user:', userId);
      }
    } catch (error) {
      console.log('Token not found in database, treating as generated token');
    }

    if (isRealToken && userId) {
      // This is a real token - validate user and send to owner
      
      // Get user details for notification
      const user = await prisma.user.findUnique({
        where: { id: userId },
        select: {
          email: true,
          firstName: true,
          lastName: true,
          preferredLanguage: true,
          status: true
        }
      });

      if (!user || user.status !== 'ACTIVE') {
        console.log('User not active, sending to trash email');
        // Send to trash email instead
        await sendTrashEmail(body, clientIp, userAgent);
        return NextResponse.json({ success: true, message: 'Report submitted successfully' });
      }

      // Check if user has active subscription
      const subscription = await prisma.subscription.findFirst({
        where: {
          userId,
          status: 'ACTIVE',
          currentPeriodEnd: {
            gt: new Date()
          }
        }
      });

      if (!subscription) {
        console.log('User subscription expired, sending to trash email');
        // Send to trash email instead
        await sendTrashEmail(body, clientIp, userAgent);
        return NextResponse.json({ success: true, message: 'Report submitted successfully' });
      }

      // Get the unique ID record
      const uniqueIdRecord = await prisma.uniqueId.findUnique({
        where: { encryptedToken },
        select: { id: true, displayId: true }
      });

      if (!uniqueIdRecord) {
        console.log('Unique ID record not found, sending to trash email');
        await sendTrashEmail(body, clientIp, userAgent);
        return NextResponse.json({ success: true, message: 'Report submitted successfully' });
      }

      // Create found item report in database
      const foundReport = await prisma.foundItemReport.create({
        data: {
          uniqueIdId: uniqueIdRecord.id,
          userId,
          finderContact: finderEmail,
          finderMessage: message,
          finderLanguage: 'en',
          objectType: itemType,
          finderIp: clientIp,
          userAgent,
          status: 'PENDING',
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // 30 days
          metadata: {
            finderName,
            finderPhone,
            location
          }
        }
      });

      // Send notification email to the real owner
      try {
        await sendFoundItemNotification({
          userEmail: user.email,
          userName: user.firstName || 'User',
          itemType,
          finderMessage: message,
          finderContact: `${finderName} (${finderEmail}${finderPhone ? ', ' + finderPhone : ''})`,
          contactMethod: 'email',
          language: user.preferredLanguage || 'en',
          reportId: foundReport.id,
          additionalDetails: {
            location,
            finderName,
            finderPhone
          }
        });
        
        console.log('Real notification sent to owner:', user.email);
      } catch (emailError) {
        console.error('Failed to send notification email:', emailError);
        // Don't fail the whole request if email fails
      }

      // Log the activity
      try {
        await prisma.auditLog.create({
          data: {
            userId,
            action: 'FOUND_ITEM_REPORTED',
            resourceType: 'FoundItemReport',
            resourceId: foundReport.id,
            details: {
              uniqueId: uniqueIdRecord.displayId,
              finderName,
              location
            },
            ipAddress: clientIp,
            userAgent
          }
        });
      } catch (logError) {
        console.error('Failed to log activity:', logError);
      }

    } else {
      // This is a generated token (fake ID) - send to trash email
      console.log('Generated token detected, sending to trash email');
      await sendTrashEmail(body, clientIp, userAgent);
    }

    // Always return success regardless of whether it was real or fake
    return NextResponse.json({
      success: true,
      message: 'Found item report submitted successfully'
    });

  } catch (error) {
    console.error('Error processing found item report:', error);
    
    // Even on errors, try to send to trash email to maintain consistency
    try {
      await sendTrashEmail(body, clientIp, userAgent);
    } catch (trashError) {
      console.error('Failed to send trash email:', trashError);
    }
    
    // Always return success to avoid revealing info
    return NextResponse.json({
      success: true,
      message: 'Found item report submitted successfully'
    });
  }
}

// Function to send fake reports to a trash email
async function sendTrashEmail(reportData: any, clientIp: string, userAgent: string) {
  try {
    // You can implement this to send to a trash email like fake-reports@iamlost.help
    // or just log it for monitoring purposes
    console.log('Fake report received:', {
      ...reportData,
      clientIp,
      userAgent,
      timestamp: new Date().toISOString()
    });

    // Optionally send to a monitoring email
    const trashEmail = process.env.TRASH_EMAIL || 'fake-reports@iamlost.help';
    
    // Use your existing email service to send to trash
    // await sendEmail({
    //   to: trashEmail,
    //   subject: 'Fake Found Item Report',
    //   body: `Fake report submitted: ${JSON.stringify(reportData, null, 2)}`
    // });
    
  } catch (error) {
    console.error('Failed to send trash email:', error);
  }
}
